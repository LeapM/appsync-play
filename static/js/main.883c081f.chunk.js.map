{"version":3,"sources":["PushData/client.ts","PushData/graphql/subscriptions.ts","PushData/index.ts","Components/EventSubscription.tsx","hooks/useGraphql.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["projectRegion","url","region","client","init","_ref","Object","asyncToGenerator","regenerator_default","a","mark","_callee","wrap","_context","prev","next","abrupt","AWSAppsyncClient","auth","type","AUTH_TYPE","AWS_IAM","credentials","AWS","IdentityPoolId","stop","apply","this","arguments","onEventDomainChange","AppSyncObservable","creator","classCallCheck","nativeObservable","subscriptions","createClass","key","value","_this","console","log","forEach","sub","buildSubscription","observer","_this2","objectSpread","error","err","resubscribe","observerOrNext","complete","Function","subscription","push","children","_this3","decorateObserverWithErrorHandler","nativeSubscription","subscribe","nativeUnsubscribe","unsubscribe","index","findIndex","v","c","splice","length","makeObservable","req","eventDomain","eventType","eventId","initClient","then","query","gql","variables","map","val","data","catch","Observable","createFailedObs","EventSubscription","props","_useGraphql","_useState","useState","_useState2","slicedToArray","event","setEvent","subscriber","obs","kill","close","useGraphql","react_default","createElement","onClick","App","Components_EventSubscription","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.883c081f.chunk.js","sourcesContent":["import AWSAppsyncClient, { AUTH_TYPE } from 'aws-appsync'\r\nimport * as AWS from 'aws-sdk'\r\nlet awsConfig = {\r\n  aws_project_region: 'ap-southeast-2',\r\n  aws_appsync_graphqlEndpoint:\r\n    'https://q3ckq5u6dvds7b3pxdtswxzjii.appsync-api.ap-southeast-2.amazonaws.com/graphql',\r\n  aws_appsync_region: 'ap-southeast-2',\r\n  aws_appsync_authenticationType: 'AWS_IAM',\r\n}\r\nlet {\r\n  aws_project_region: projectRegion,\r\n  aws_appsync_graphqlEndpoint: url,\r\n  aws_appsync_region: region,\r\n  aws_appsync_authenticationType: type,\r\n} = awsConfig\r\n\r\nconst IdentityPoolId = 'ap-southeast-2:43d98a1a-65ef-496d-ba6d-ca788632a755'\r\nlet client: AWSAppsyncClient<any> | null = null\r\n\r\nconst init = async () => {\r\n  if (client) return client\r\n  client = new AWSAppsyncClient({\r\n    url,\r\n    region: projectRegion,\r\n    auth: {\r\n      type: AUTH_TYPE.AWS_IAM,\r\n      credentials: new AWS.CognitoIdentityCredentials(\r\n        {\r\n          IdentityPoolId,\r\n        },\r\n        {\r\n          region,\r\n        }\r\n      ),\r\n    },\r\n  })\r\n\r\n  // client.hydrated().then(client => {\r\n  //   console.log('hydrated completed')\r\n  // })\r\n  return client\r\n}\r\n\r\nexport default init\r\n","// tslint:disable\n// this is an auto generated file. This will be overwritten\n\nexport const onEventDomainChange = `subscription OnEventDomainChange($eventDomain: String) {\n  onEventDomainChange(eventDomain: $eventDomain) {\n    id\n    eventDomain\n    eventType\n    sequence\n    eventId\n    eventKey\n    version\n    origin\n    producer\n    producerVersion\n    emitterId\n    emitterTimestamp\n    consumerTimestamp\n    created\n    data\n  }\n}\n`;\nexport const onEventDomainChanges = `subscription OnEventDomainChanges($eventDomain: String) {\n  onEventDomainChanges(eventDomain: $eventDomain) {\n    id\n    eventDomain\n    eventType\n    sequence\n    eventId\n    eventKey\n    version\n    origin\n    producer\n    producerVersion\n    emitterId\n    emitterTimestamp\n    consumerTimestamp\n    created\n    data\n  }\n}\n`;\nexport const onEventDomainTypeChange = `subscription OnEventDomainTypeChange(\n  $eventDomain: String!\n  $eventType: String!\n) {\n  onEventDomainTypeChange(eventDomain: $eventDomain, eventType: $eventType) {\n    id\n    eventDomain\n    eventType\n    sequence\n    eventId\n    eventKey\n    version\n    origin\n    producer\n    producerVersion\n    emitterId\n    emitterTimestamp\n    consumerTimestamp\n    created\n    data\n  }\n}\n`;\nexport const onEventDomainTypeChanges = `subscription OnEventDomainTypeChanges(\n  $eventDomain: String!\n  $eventType: [String!]\n) {\n  onEventDomainTypeChanges(eventDomain: $eventDomain, eventType: $eventType) {\n    id\n    eventDomain\n    eventType\n    sequence\n    eventId\n    eventKey\n    version\n    origin\n    producer\n    producerVersion\n    emitterId\n    emitterTimestamp\n    consumerTimestamp\n    created\n    data\n  }\n}\n`;\nexport const onEventDomainKeyChange = `subscription OnEventDomainKeyChange($eventDomain: String!, $eventKey: String!) {\n  onEventDomainKeyChange(eventDomain: $eventDomain, eventKey: $eventKey) {\n    id\n    eventDomain\n    eventType\n    sequence\n    eventId\n    eventKey\n    version\n    origin\n    producer\n    producerVersion\n    emitterId\n    emitterTimestamp\n    consumerTimestamp\n    created\n    data\n  }\n}\n`;\nexport const onEventDomainKeyChanges = `subscription OnEventDomainKeyChanges(\n  $eventDomain: String!\n  $eventKey: String!\n) {\n  onEventDomainKeyChanges(eventDomain: $eventDomain, eventKey: $eventKey) {\n    id\n    eventDomain\n    eventType\n    sequence\n    eventId\n    eventKey\n    version\n    origin\n    producer\n    producerVersion\n    emitterId\n    emitterTimestamp\n    consumerTimestamp\n    created\n    data\n  }\n}\n`;\nexport const onEventDomainEventIdChange = `subscription OnEventDomainEventIdChange(\n  $eventDomain: String!\n  $eventId: String!\n) {\n  onEventDomainEventIdChange(eventDomain: $eventDomain, eventId: $eventId) {\n    id\n    eventDomain\n    eventType\n    sequence\n    eventId\n    eventKey\n    version\n    origin\n    producer\n    producerVersion\n    emitterId\n    emitterTimestamp\n    consumerTimestamp\n    created\n    data\n  }\n}\n`;\nexport const onEventDomainEventIdChanges = `subscription OnEventDomainEventIdChanges(\n  $eventDomain: String!\n  $eventId: [String!]\n) {\n  onEventDomainEventIdChanges(eventDomain: $eventDomain, eventId: $eventId) {\n    id\n    eventDomain\n    eventType\n    sequence\n    eventId\n    eventKey\n    version\n    origin\n    producer\n    producerVersion\n    emitterId\n    emitterTimestamp\n    consumerTimestamp\n    created\n    data\n  }\n}\n`;\n","import initClient from './client'\r\nimport gql from 'graphql-tag'\r\nimport ZenObservable from 'zen-observable-ts'\r\nimport { onEventDomainChange } from './graphql/subscriptions'\r\nimport { Observable } from 'apollo-client/util/Observable'\r\n\r\ninterface MakeObservableReq {\r\n  eventDomain?: string\r\n  eventType?: string\r\n  eventId?: string\r\n}\r\n\r\ninterface SubscriptionMeta<T> {\r\n  subscription: ZenObservable.Subscription\r\n  children: ZenObservable.Subscription[]\r\n  observer: ZenObservable.Observer<T>\r\n}\r\nexport class AppSyncObservable<T> {\r\n  private nativeObservable: ZenObservable<T>\r\n  private subscriptions: SubscriptionMeta<T>[] = []\r\n  private creator: Function\r\n\r\n  constructor(creator: Function) {\r\n    this.creator = creator\r\n    this.nativeObservable = creator()\r\n  }\r\n\r\n  private resubscribe() {\r\n    console.log('call resubcript')\r\n    this.nativeObservable = this.creator()\r\n    this.subscriptions.forEach(sub => this.buildSubscription(sub.observer))\r\n  }\r\n\r\n  private decorateObserverWithErrorHandler<T>(\r\n    observer: ZenObservable.Observer<T>\r\n  ) {\r\n    return {\r\n      ...observer,\r\n      error: (err: any) => {\r\n        console.error('error happend with network')\r\n        if (err === 'disconnect') {\r\n          this.resubscribe()\r\n        } else if (observer.error) {\r\n          observer.error(err)\r\n        }\r\n      },\r\n    }\r\n  }\r\n\r\n  public subscribe(\r\n    observerOrNext: ((value: T) => void) | ZenObservable.Observer<T>,\r\n    error?: (error: any) => void,\r\n    complete?: () => void\r\n  ) {\r\n    let observer =\r\n      observerOrNext instanceof Function\r\n        ? {\r\n            next: observerOrNext,\r\n            error,\r\n            complete,\r\n          }\r\n        : observerOrNext\r\n    let subscription = this.buildSubscription(observer)\r\n    this.subscriptions.push({\r\n      subscription,\r\n      children: [],\r\n      observer,\r\n    })\r\n\r\n    console.log(this.subscriptions)\r\n\r\n    return subscription\r\n  }\r\n\r\n  private buildSubscription(observer: ZenObservable.Observer<T>) {\r\n    // tslint:disable-next-line:no-console\r\n\r\n    observer = this.decorateObserverWithErrorHandler(observer)\r\n    const nativeSubscription = this.nativeObservable.subscribe(observer)\r\n    const nativeUnsubscribe = nativeSubscription.unsubscribe\r\n    nativeSubscription.unsubscribe = () => {\r\n      const index = this.subscriptions.findIndex(\r\n        v => v.subscription == nativeSubscription\r\n      )\r\n      if (index >= 0) {\r\n        console.log('find cached subscription', this.subscriptions[0])\r\n        this.subscriptions[index].children.forEach(c => c.unsubscribe())\r\n        this.subscriptions.splice(index, 1)\r\n      }\r\n\r\n      if (this.subscriptions.length == 0) console.log('unsubscribe event')\r\n      nativeUnsubscribe.apply(nativeSubscription)\r\n    }\r\n\r\n    return nativeSubscription\r\n  }\r\n}\r\n\r\nfunction createFailedObs<T>(error: any) {\r\n  return new AppSyncObservable<T>(\r\n    () => new Observable<T>(observer => observer.error(error))\r\n  )\r\n}\r\n\r\nfunction makeObservable<T>(\r\n  req: MakeObservableReq\r\n): Promise<AppSyncObservable<T>> {\r\n  // Add logic to support other subscription\r\n  const { eventDomain, eventType, eventId } = req\r\n  return initClient()\r\n    .then(client => {\r\n      let creator = () => {\r\n        let obs = client!.subscribe({\r\n          query: gql(onEventDomainChange),\r\n          variables: { eventDomain },\r\n        })\r\n        return obs.map<T>(val => val.data)\r\n      }\r\n      return new AppSyncObservable<T>(creator)\r\n    })\r\n    .catch(error => {\r\n      return createFailedObs<T>(error)\r\n    })\r\n}\r\n\r\nexport default makeObservable\r\n","import React from 'react'\r\nimport makeObservable from '../PushData/index'\r\nimport useGraphql from '../hooks/useGraphql'\r\n\r\nconst EventSubscription: React.FC = props => {\r\n  let { event, subscribe, unsubscribe, kill} = useGraphql()\r\n  return (\r\n    <div>\r\n      <h1>AppSync network connection testing</h1>\r\n      <div>\r\n        <button onClick={() => subscribe('race')}>Subscribe</button>\r\n      </div>\r\n      <div>\r\n        <button onClick = {unsubscribe}>Unsubscribe</button>{' '}\r\n      </div>\r\n      <div>\r\n        <button onClick = {kill}>  Kill connection</button>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default EventSubscription\r\n","import { useState, useEffect } from 'react'\r\nimport makeObservable from '../PushData'\r\nimport { OnEventDomainChangeSubscription as DomainChangeEvent } from '../PushData/API'\r\nimport Observable from 'zen-observable-ts'\r\nimport { OnEventDomainChangeSubscription as DomainEvent } from '../PushData/API'\r\nexport default () => {\r\n  let [event, setEvent] = useState()\r\n  let subscriber: any = null\r\n  // useEffect(() => {\r\n  //   let newEvent = event\r\n  //   let interval = setInterval(() => {\r\n  //     newEvent++\r\n  //     setEvent(newEvent)\r\n  //   }, 1000)\r\n\r\n  //   return () => {\r\n  //     clearInterval(interval)\r\n  //   }\r\n  // }, [])\r\n  let subscribe = (eventDomain: string) => {\r\n    console.log('calling subscribe')\r\n    makeObservable<DomainEvent>({ eventDomain }).then(obs => {\r\n      subscriber = obs.subscribe(\r\n        data => {\r\n          console.log(data)\r\n          setEvent(data)\r\n        },\r\n        error => console.log('error', error),\r\n        () => console.log('completed')\r\n      )\r\n    })\r\n  }\r\n  let kill = () => {\r\n    console.log('calling kill') \r\n    subscriber && subscriber.close()\r\n  }\r\n  let unsubscribe = () => {\r\n    console.log('calling unsubscribe')\r\n    if (subscriber) {\r\n      subscriber.unsubscribe()\r\n      subscriber = null\r\n    }\r\n  }\r\n  return { event, subscribe, unsubscribe, kill }\r\n}\r\n","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport EventSubscription from './Components/EventSubscription';\n\nconst App: React.FC = () => {\n  return (\n    <EventSubscription/>\n    // <div> hello </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}